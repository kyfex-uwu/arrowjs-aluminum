import {type ArrowTemplate, html} from "@arrow-js/core";

type attr = string|(()=>string)|((e:Event)=>void);

function extendAttributes(originalAttrs:{[attribute:string]:attr},transformers:{
    add?:{[attribute:string]:attr},
    replace?:{[attribute:string]:attr},
    transform?:{[attribute:string]:(previousValue:attr|undefined)=>attr}}){

    const newAttributes = {...originalAttrs};
    if(transformers.add !== undefined){
        for(const [attribute, addValue] of Object.entries(transformers.add)){
            if(newAttributes[attribute] === undefined)
                newAttributes[attribute] = addValue;
            else if(typeof addValue === "string") {
                if (typeof newAttributes[attribute] === "string")
                    newAttributes[attribute] += " " + addValue;
                else {
                    const old = newAttributes[attribute] as (()=>string);
                    newAttributes[attribute] = () => old() + " " + addValue;
                }
            }else{
                const old = newAttributes[attribute] as (()=>string);
                if (typeof old === "function")
                    newAttributes[attribute] = () => old() + " " + (addValue as (()=>string))();
                else
                    newAttributes[attribute] = () => (addValue as (()=>string))() + " " + old;
            }
        }
    }
    if(transformers.replace !== undefined) Object.assign(newAttributes, transformers.replace);
    if(transformers.transform !== undefined){
        for(const [attribute, transformer] of Object.entries(transformers.transform)){
            newAttributes[attribute] = transformer(newAttributes[attribute]);
        }
    }

    return newAttributes;
}

/**
 * A generator for extendable templates that can be rendered. In other frameworks, this would be a "component generator"
 */
export class ArrowElementGenerator<T>{
    public readonly type;
    protected readonly attributes;
    protected readonly createTransform;

    /**
     * Creates an ArrowElement
     * @param type The underlying type of this element: div, span, etc
     * @param attributes The attributes on this element
     * @param createTransform A function that gets run when {@link create} is called. See {@link create} for more info
     */
    constructor(type:string, attributes:{[attribute:string]:attr},
                createTransform:(args:T, currentAttributes:{[attribute:string]:attr})=>void){
        this.type = type;
        this.attributes = attributes;
        this.createTransform=createTransform;
    }

    /**
     * Creates a new template from this generator, optionally adding some additional attributes
     * @param contents The contents of this template (the stuff between the tags)
     * @param requiredValue The value you need to pass into this generator, specified when the generator was created (the `createTransform`)
     * @param attributes Additional attributes to add to this template
     * @return A renderable {@link ArrowTemplate}
     */
    create(contents:string|(()=>string)|ArrowTemplate|(()=>ArrowTemplate), requiredValue:T, attributes:{
        add?:{[attribute:string]:attr},
        replace?:{[attribute:string]:attr},
        transform?:{[attribute:string]:(previousValue:attr|undefined)=>attr}}={}){

        const newAttributes = {...this.attributes};
        this.createTransform(requiredValue, newAttributes);
        const newerAttributes = extendAttributes(newAttributes, attributes);
        const orderedContents = Object.entries(newerAttributes);

        const staticStringContents = [`<${this.type} `+(orderedContents.length===0?">":orderedContents[0]![0]+'="'),
            ...orderedContents.slice(1).map(data=>`" ${data[0]}="`),
            ...(orderedContents.length>0?['">']:[]), `</${this.type}>`] as unknown as TemplateStringsArray;
        // @ts-ignore
        staticStringContents.raw=[...staticStringContents];

        return html(staticStringContents,
            ...[...orderedContents.map(data => data[1]), contents]);
    }

    /**
     * Creates a new generator based on this one
     * @param attributes Additional attributes to add to future templates generated by this new generator
     * @param newCreateTransform Takes the `requiredValue` from {@link create} and the attributes of this generator,
     * and applies the `requiredValue` to the attributes
     * @param type The node type of this template. Optional, will inherit from parent if not specified
     * @return A new {@link ArrowElementGenerator} with the specified attributes, type, and transform function
     */
    extend<T2>(attributes:{
        add?:{[attribute:string]:attr},
        replace?:{[attribute:string]:attr},
        transform?:{[attribute:string]:(previousValue:attr|undefined)=>attr}},
            newCreateTransform:(superTransform: (args: T, currentAttributes: {
                [attribute: string]: attr
            }) => void) =>
                (args:T2, currentAttributes:{
                    [attribute:string]: attr
                }) => void,
            type?:string){

        return new ArrowElementGenerator(type || this.type, extendAttributes(this.attributes, attributes), newCreateTransform(this.createTransform));
    }
}

const defaultGenerator = new ArrowElementGenerator("",{}, ()=>{});
/**
 * Creates a new generator
 * @param type The node type of this template
 * @param attributes The attributes to add to all templates made by this generator
 * @param createTransform A function that gets run when {@link create} is called. See {@link create} for more info
 * @return A new {@link ArrowElementGenerator} with the specified attributes, type, and transform function
 */
export default function createGenerator<T>(type:string, attributes:{[attribute:string]:attr},
        createTransform: (args:T, currentAttributes:{
            [attribute:string]:attr
        })=>void = ()=>{}){
    return defaultGenerator.extend({replace:attributes}, ()=>createTransform, type);
}
